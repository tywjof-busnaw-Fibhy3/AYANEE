<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <title>Interactive 3D Portfolio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>html,body{height:100%;margin:0} canvas{display:block}</style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dat.gui/build/dat.gui.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
<script>
    const scene = new THREE.Scene();
    // ฉากสีอ่อน + มองทะลุเห็น "พื้น" ด้านหลังวัตถุได้
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
    camera.position.set(0, 5, 25);

    /* Auto-exported from Blender */
    //const vertices = [];

    //const uvs = [];

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMap.enabled = true;
    renderer.physicallyCorrectLights = true;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);

    new THREE.OrbitControls(camera, renderer.domElement);

    // แสง
    scene.add(new THREE.HemisphereLight(0xffffff, 0x333333, 0.6)); // แสงสว่างรอบทิศทาง
    const dir = new THREE.DirectionalLight(0xffffff, 3.0);
    dir.position.set(3, 5, 2);
    dir.castShadow = true;
    scene.add(dir);

    // โหลด texture พื้น
    const textureLoader = new THREE.TextureLoader();
    const exrLoader = new THREE.EXRLoader();

    const groundBaseColor = textureLoader.load('https://tywjof-busnaw-fibhy3.github.io/AYANEE/laminate_floor_02_diff_2k.jpg');
    const groundAO        = textureLoader.load('https://tywjof-busnaw-fibhy3.github.io/AYANEE/laminate_floor_02_ao_2k.jpg');
    const groundARM       = textureLoader.load('https://tywjof-busnaw-fibhy3.github.io/AYANEE/laminate_floor_02_arm_2k.jpg');
    const groundDisp      = textureLoader.load('https://tywjof-busnaw-fibhy3.github.io/AYANEE/laminate_floor_02_disp_2k.png');

    // normal / roughness ใช้ EXRLoader
    let groundNormal, groundRough;
    exrLoader.load('https://tywjof-busnaw-fibhy3.github.io/AYANEE/laminate_floor_02_nor_gl_2k.exr', (tex) => {
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(4,4);
        groundNormal = tex;
    });
    exrLoader.load('https://tywjof-busnaw-fibhy3.github.io/AYANEE/laminate_floor_02_rough_2k.exr', (tex) => {
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(4,4);
        groundRough = tex;
    });

    // base textures repeat
    [groundBaseColor, groundAO, groundARM, groundDisp].forEach(tex => {
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(4,4);
    });

    // พื้น
    const groundMaterial = new THREE.MeshStandardMaterial({
        map: groundBaseColor,
        aoMap: groundAO,
        normalMap: groundNormal,
        roughnessMap: groundRough,
        displacementMap: groundDisp,
        displacementScale: 0.1,
        roughness: 0.8,
        metalness: 0.0
    });

    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(40, 40, 200, 200),
        groundMaterial
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);



    const envMap = new THREE.RGBELoader()
    .setDataType(THREE.UnsignedByteType) // ใช้ข้อมูลแบบ UnsignedByte
    .load('https://tywjof-busnaw-fibhy3.github.io/AYANEE/sculpture_exhibition_2k.hdr', function(texture) {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        scene.background = texture;
        scene.environment = texture;
    });


    addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });

    let t = 0;
    (function loop(){
        t += 0.01;
        dir.position.x = 3 + Math.sin(t)*1.0; // แสงเคลื่อนที่
        renderer.render(scene, camera);
        requestAnimationFrame(loop);
    })();

    window.addEventListener('keydown', (event) => {
        
        
        });
</script>
</body>
</html>
